<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aws_lambda_powertools.utilities.parameters.base API documentation</title>
<meta name="description" content="Base for Parameter providers" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aws_lambda_powertools.utilities.parameters.base</code></h1>
</header>
<section id="section-intro">
<p>Base for Parameter providers</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Base for Parameter providers
&#34;&#34;&#34;

import base64
import json
from abc import ABC, abstractmethod
from collections import namedtuple
from datetime import datetime, timedelta
from typing import Any, Dict, Optional, Tuple, Union

from .exceptions import GetParameterError, TransformParameterError

DEFAULT_MAX_AGE_SECS = 5
ExpirableValue = namedtuple(&#34;ExpirableValue&#34;, [&#34;value&#34;, &#34;ttl&#34;])
# These providers will be dynamically initialized on first use of the helper functions
DEFAULT_PROVIDERS: Dict[str, Any] = {}
TRANSFORM_METHOD_JSON = &#34;json&#34;
TRANSFORM_METHOD_BINARY = &#34;binary&#34;
SUPPORTED_TRANSFORM_METHODS = [TRANSFORM_METHOD_JSON, TRANSFORM_METHOD_BINARY]


class BaseProvider(ABC):
    &#34;&#34;&#34;
    Abstract Base Class for Parameter providers
    &#34;&#34;&#34;

    store: Any = None

    def __init__(self):
        &#34;&#34;&#34;
        Initialize the base provider
        &#34;&#34;&#34;

        self.store = {}

    def _has_not_expired(self, key: Tuple[str, Optional[str]]) -&gt; bool:
        return key in self.store and self.store[key].ttl &gt;= datetime.now()

    def get(
        self,
        name: str,
        max_age: int = DEFAULT_MAX_AGE_SECS,
        transform: Optional[str] = None,
        force_fetch: bool = False,
        **sdk_options,
    ) -&gt; Union[str, list, dict, bytes]:
        &#34;&#34;&#34;
        Retrieve a parameter value or return the cached value

        Parameters
        ----------
        name: str
            Parameter name
        max_age: int
            Maximum age of the cached value
        transform: str
            Optional transformation of the parameter value. Supported values
            are &#34;json&#34; for JSON strings and &#34;binary&#34; for base 64 encoded
            values.
        force_fetch: bool, optional
            Force update even before a cached item has expired, defaults to False
        sdk_options: dict, optional
            Arguments that will be passed directly to the underlying API call

        Raises
        ------
        GetParameterError
            When the parameter provider fails to retrieve a parameter value for
            a given name.
        TransformParameterError
            When the parameter provider fails to transform a parameter value.
        &#34;&#34;&#34;

        # If there are multiple calls to the same parameter but in a different
        # transform, they will be stored multiple times. This allows us to
        # optimize by transforming the data only once per retrieval, thus there
        # is no need to transform cached values multiple times. However, this
        # means that we need to make multiple calls to the underlying parameter
        # store if we need to return it in different transforms. Since the number
        # of supported transform is small and the probability that a given
        # parameter will always be used in a specific transform, this should be
        # an acceptable tradeoff.
        key = (name, transform)

        if not force_fetch and self._has_not_expired(key):
            return self.store[key].value

        try:
            value = self._get(name, **sdk_options)
        # Encapsulate all errors into a generic GetParameterError
        except Exception as exc:
            raise GetParameterError(str(exc))

        if transform is not None:
            if isinstance(value, bytes):
                value = value.decode(&#34;utf-8&#34;)
            value = transform_value(value, transform)

        self.store[key] = ExpirableValue(value, datetime.now() + timedelta(seconds=max_age))

        return value

    @abstractmethod
    def _get(self, name: str, **sdk_options) -&gt; Union[str, bytes]:
        &#34;&#34;&#34;
        Retrieve parameter value from the underlying parameter store
        &#34;&#34;&#34;
        raise NotImplementedError()

    def get_multiple(
        self,
        path: str,
        max_age: int = DEFAULT_MAX_AGE_SECS,
        transform: Optional[str] = None,
        raise_on_transform_error: bool = False,
        force_fetch: bool = False,
        **sdk_options,
    ) -&gt; Union[Dict[str, str], Dict[str, dict], Dict[str, bytes]]:
        &#34;&#34;&#34;
        Retrieve multiple parameters based on a path prefix

        Parameters
        ----------
        path: str
            Parameter path used to retrieve multiple parameters
        max_age: int, optional
            Maximum age of the cached value
        transform: str, optional
            Optional transformation of the parameter value. Supported values
            are &#34;json&#34; for JSON strings, &#34;binary&#34; for base 64 encoded
            values or &#34;auto&#34; which looks at the attribute key to determine the type.
        raise_on_transform_error: bool, optional
            Raises an exception if any transform fails, otherwise this will
            return a None value for each transform that failed
        force_fetch: bool, optional
            Force update even before a cached item has expired, defaults to False
        sdk_options: dict, optional
            Arguments that will be passed directly to the underlying API call

        Raises
        ------
        GetParameterError
            When the parameter provider fails to retrieve parameter values for
            a given path.
        TransformParameterError
            When the parameter provider fails to transform a parameter value.
        &#34;&#34;&#34;

        key = (path, transform)

        if not force_fetch and self._has_not_expired(key):
            return self.store[key].value

        try:
            values: Dict[str, Union[str, bytes, dict, None]] = self._get_multiple(path, **sdk_options)
        # Encapsulate all errors into a generic GetParameterError
        except Exception as exc:
            raise GetParameterError(str(exc))

        if transform is not None:
            for (key, value) in values.items():
                _transform = get_transform_method(key, transform)
                if _transform is None:
                    continue

                values[key] = transform_value(value, _transform, raise_on_transform_error)

        self.store[key] = ExpirableValue(values, datetime.now() + timedelta(seconds=max_age))

        return values

    @abstractmethod
    def _get_multiple(self, path: str, **sdk_options) -&gt; Dict[str, str]:
        &#34;&#34;&#34;
        Retrieve multiple parameter values from the underlying parameter store
        &#34;&#34;&#34;
        raise NotImplementedError()


def get_transform_method(key: str, transform: Optional[str] = None) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Determine the transform method

    Examples
    -------
        &gt;&gt;&gt; get_transform_method(&#34;key&#34;, &#34;any_other_value&#34;)
        &#39;any_other_value&#39;
        &gt;&gt;&gt; get_transform_method(&#34;key.json&#34;, &#34;auto&#34;)
        &#39;json&#39;
        &gt;&gt;&gt; get_transform_method(&#34;key.binary&#34;, &#34;auto&#34;)
        &#39;binary&#39;
        &gt;&gt;&gt; get_transform_method(&#34;key&#34;, &#34;auto&#34;)
        None
        &gt;&gt;&gt; get_transform_method(&#34;key&#34;, None)
        None

    Parameters
    ---------
    key: str
        Only used when the tranform is &#34;auto&#34;.
    transform: str, optional
        Original transform method, only &#34;auto&#34; will try to detect the transform method by the key

    Returns
    ------
    Optional[str]:
        The transform method either when transform is &#34;auto&#34; then None, &#34;json&#34; or &#34;binary&#34; is returned
        or the original transform method
    &#34;&#34;&#34;
    if transform != &#34;auto&#34;:
        return transform

    for transform_method in SUPPORTED_TRANSFORM_METHODS:
        if key.endswith(&#34;.&#34; + transform_method):
            return transform_method
    return None


def transform_value(value: str, transform: str, raise_on_transform_error: bool = True) -&gt; Union[dict, bytes, None]:
    &#34;&#34;&#34;
    Apply a transform to a value

    Parameters
    ---------
    value: str
        Parameter value to transform
    transform: str
        Type of transform, supported values are &#34;json&#34; and &#34;binary&#34;
    raise_on_transform_error: bool, optional
        Raises an exception if any transform fails, otherwise this will
        return a None value for each transform that failed

    Raises
    ------
    TransformParameterError:
        When the parameter value could not be transformed
    &#34;&#34;&#34;

    try:
        if transform == TRANSFORM_METHOD_JSON:
            return json.loads(value)
        elif transform == TRANSFORM_METHOD_BINARY:
            return base64.b64decode(value)
        else:
            raise ValueError(f&#34;Invalid transform type &#39;{transform}&#39;&#34;)

    except Exception as exc:
        if raise_on_transform_error:
            raise TransformParameterError(str(exc))
        return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="aws_lambda_powertools.utilities.parameters.base.get_transform_method"><code class="name flex">
<span>def <span class="ident">get_transform_method</span></span>(<span>key: str, transform: Optional[str] = None) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Determine the transform method</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; get_transform_method("key", "any_other_value")
'any_other_value'
&gt;&gt;&gt; get_transform_method("key.json", "auto")
'json'
&gt;&gt;&gt; get_transform_method("key.binary", "auto")
'binary'
&gt;&gt;&gt; get_transform_method("key", "auto")
None
&gt;&gt;&gt; get_transform_method("key", None)
None
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Only used when the tranform is "auto".</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Original transform method, only "auto" will try to detect the transform method by the key</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[str]:</code></dt>
<dd>The transform method either when transform is "auto" then None, "json" or "binary" is returned
or the original transform method</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transform_method(key: str, transform: Optional[str] = None) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Determine the transform method

    Examples
    -------
        &gt;&gt;&gt; get_transform_method(&#34;key&#34;, &#34;any_other_value&#34;)
        &#39;any_other_value&#39;
        &gt;&gt;&gt; get_transform_method(&#34;key.json&#34;, &#34;auto&#34;)
        &#39;json&#39;
        &gt;&gt;&gt; get_transform_method(&#34;key.binary&#34;, &#34;auto&#34;)
        &#39;binary&#39;
        &gt;&gt;&gt; get_transform_method(&#34;key&#34;, &#34;auto&#34;)
        None
        &gt;&gt;&gt; get_transform_method(&#34;key&#34;, None)
        None

    Parameters
    ---------
    key: str
        Only used when the tranform is &#34;auto&#34;.
    transform: str, optional
        Original transform method, only &#34;auto&#34; will try to detect the transform method by the key

    Returns
    ------
    Optional[str]:
        The transform method either when transform is &#34;auto&#34; then None, &#34;json&#34; or &#34;binary&#34; is returned
        or the original transform method
    &#34;&#34;&#34;
    if transform != &#34;auto&#34;:
        return transform

    for transform_method in SUPPORTED_TRANSFORM_METHODS:
        if key.endswith(&#34;.&#34; + transform_method):
            return transform_method
    return None</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.parameters.base.transform_value"><code class="name flex">
<span>def <span class="ident">transform_value</span></span>(<span>value: str, transform: str, raise_on_transform_error: bool = True) ‑> Union[dict, bytes, None]</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a transform to a value</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Parameter value to transform</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of transform, supported values are "json" and "binary"</dd>
<dt><strong><code>raise_on_transform_error</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Raises an exception if any transform fails, otherwise this will
return a None value for each transform that failed</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="transformparametererror">Transformparametererror</h2>
<p>When the parameter value could not be transformed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_value(value: str, transform: str, raise_on_transform_error: bool = True) -&gt; Union[dict, bytes, None]:
    &#34;&#34;&#34;
    Apply a transform to a value

    Parameters
    ---------
    value: str
        Parameter value to transform
    transform: str
        Type of transform, supported values are &#34;json&#34; and &#34;binary&#34;
    raise_on_transform_error: bool, optional
        Raises an exception if any transform fails, otherwise this will
        return a None value for each transform that failed

    Raises
    ------
    TransformParameterError:
        When the parameter value could not be transformed
    &#34;&#34;&#34;

    try:
        if transform == TRANSFORM_METHOD_JSON:
            return json.loads(value)
        elif transform == TRANSFORM_METHOD_BINARY:
            return base64.b64decode(value)
        else:
            raise ValueError(f&#34;Invalid transform type &#39;{transform}&#39;&#34;)

    except Exception as exc:
        if raise_on_transform_error:
            raise TransformParameterError(str(exc))
        return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aws_lambda_powertools.utilities.parameters.base.BaseProvider"><code class="flex name class">
<span>class <span class="ident">BaseProvider</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract Base Class for Parameter providers</p>
<p>Initialize the base provider</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseProvider(ABC):
    &#34;&#34;&#34;
    Abstract Base Class for Parameter providers
    &#34;&#34;&#34;

    store: Any = None

    def __init__(self):
        &#34;&#34;&#34;
        Initialize the base provider
        &#34;&#34;&#34;

        self.store = {}

    def _has_not_expired(self, key: Tuple[str, Optional[str]]) -&gt; bool:
        return key in self.store and self.store[key].ttl &gt;= datetime.now()

    def get(
        self,
        name: str,
        max_age: int = DEFAULT_MAX_AGE_SECS,
        transform: Optional[str] = None,
        force_fetch: bool = False,
        **sdk_options,
    ) -&gt; Union[str, list, dict, bytes]:
        &#34;&#34;&#34;
        Retrieve a parameter value or return the cached value

        Parameters
        ----------
        name: str
            Parameter name
        max_age: int
            Maximum age of the cached value
        transform: str
            Optional transformation of the parameter value. Supported values
            are &#34;json&#34; for JSON strings and &#34;binary&#34; for base 64 encoded
            values.
        force_fetch: bool, optional
            Force update even before a cached item has expired, defaults to False
        sdk_options: dict, optional
            Arguments that will be passed directly to the underlying API call

        Raises
        ------
        GetParameterError
            When the parameter provider fails to retrieve a parameter value for
            a given name.
        TransformParameterError
            When the parameter provider fails to transform a parameter value.
        &#34;&#34;&#34;

        # If there are multiple calls to the same parameter but in a different
        # transform, they will be stored multiple times. This allows us to
        # optimize by transforming the data only once per retrieval, thus there
        # is no need to transform cached values multiple times. However, this
        # means that we need to make multiple calls to the underlying parameter
        # store if we need to return it in different transforms. Since the number
        # of supported transform is small and the probability that a given
        # parameter will always be used in a specific transform, this should be
        # an acceptable tradeoff.
        key = (name, transform)

        if not force_fetch and self._has_not_expired(key):
            return self.store[key].value

        try:
            value = self._get(name, **sdk_options)
        # Encapsulate all errors into a generic GetParameterError
        except Exception as exc:
            raise GetParameterError(str(exc))

        if transform is not None:
            if isinstance(value, bytes):
                value = value.decode(&#34;utf-8&#34;)
            value = transform_value(value, transform)

        self.store[key] = ExpirableValue(value, datetime.now() + timedelta(seconds=max_age))

        return value

    @abstractmethod
    def _get(self, name: str, **sdk_options) -&gt; Union[str, bytes]:
        &#34;&#34;&#34;
        Retrieve parameter value from the underlying parameter store
        &#34;&#34;&#34;
        raise NotImplementedError()

    def get_multiple(
        self,
        path: str,
        max_age: int = DEFAULT_MAX_AGE_SECS,
        transform: Optional[str] = None,
        raise_on_transform_error: bool = False,
        force_fetch: bool = False,
        **sdk_options,
    ) -&gt; Union[Dict[str, str], Dict[str, dict], Dict[str, bytes]]:
        &#34;&#34;&#34;
        Retrieve multiple parameters based on a path prefix

        Parameters
        ----------
        path: str
            Parameter path used to retrieve multiple parameters
        max_age: int, optional
            Maximum age of the cached value
        transform: str, optional
            Optional transformation of the parameter value. Supported values
            are &#34;json&#34; for JSON strings, &#34;binary&#34; for base 64 encoded
            values or &#34;auto&#34; which looks at the attribute key to determine the type.
        raise_on_transform_error: bool, optional
            Raises an exception if any transform fails, otherwise this will
            return a None value for each transform that failed
        force_fetch: bool, optional
            Force update even before a cached item has expired, defaults to False
        sdk_options: dict, optional
            Arguments that will be passed directly to the underlying API call

        Raises
        ------
        GetParameterError
            When the parameter provider fails to retrieve parameter values for
            a given path.
        TransformParameterError
            When the parameter provider fails to transform a parameter value.
        &#34;&#34;&#34;

        key = (path, transform)

        if not force_fetch and self._has_not_expired(key):
            return self.store[key].value

        try:
            values: Dict[str, Union[str, bytes, dict, None]] = self._get_multiple(path, **sdk_options)
        # Encapsulate all errors into a generic GetParameterError
        except Exception as exc:
            raise GetParameterError(str(exc))

        if transform is not None:
            for (key, value) in values.items():
                _transform = get_transform_method(key, transform)
                if _transform is None:
                    continue

                values[key] = transform_value(value, _transform, raise_on_transform_error)

        self.store[key] = ExpirableValue(values, datetime.now() + timedelta(seconds=max_age))

        return values

    @abstractmethod
    def _get_multiple(self, path: str, **sdk_options) -&gt; Dict[str, str]:
        &#34;&#34;&#34;
        Retrieve multiple parameter values from the underlying parameter store
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parameters.appconfig.AppConfigProvider" href="appconfig.html#aws_lambda_powertools.utilities.parameters.appconfig.AppConfigProvider">AppConfigProvider</a></li>
<li><a title="aws_lambda_powertools.utilities.parameters.dynamodb.DynamoDBProvider" href="dynamodb.html#aws_lambda_powertools.utilities.parameters.dynamodb.DynamoDBProvider">DynamoDBProvider</a></li>
<li><a title="aws_lambda_powertools.utilities.parameters.secrets.SecretsProvider" href="secrets.html#aws_lambda_powertools.utilities.parameters.secrets.SecretsProvider">SecretsProvider</a></li>
<li><a title="aws_lambda_powertools.utilities.parameters.ssm.SSMProvider" href="ssm.html#aws_lambda_powertools.utilities.parameters.ssm.SSMProvider">SSMProvider</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parameters.base.BaseProvider.store"><code class="name">var <span class="ident">store</span> : Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parameters.base.BaseProvider.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name: str, max_age: int = 5, transform: Optional[str] = None, force_fetch: bool = False, **sdk_options) ‑> Union[str, list, dict, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a parameter value or return the cached value</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Parameter name</dd>
<dt><strong><code>max_age</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum age of the cached value</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>str</code></dt>
<dd>Optional transformation of the parameter value. Supported values
are "json" for JSON strings and "binary" for base 64 encoded
values.</dd>
<dt><strong><code>force_fetch</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Force update even before a cached item has expired, defaults to False</dd>
<dt><strong><code>sdk_options</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Arguments that will be passed directly to the underlying API call</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GetParameterError</code></dt>
<dd>When the parameter provider fails to retrieve a parameter value for
a given name.</dd>
<dt><code>TransformParameterError</code></dt>
<dd>When the parameter provider fails to transform a parameter value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(
    self,
    name: str,
    max_age: int = DEFAULT_MAX_AGE_SECS,
    transform: Optional[str] = None,
    force_fetch: bool = False,
    **sdk_options,
) -&gt; Union[str, list, dict, bytes]:
    &#34;&#34;&#34;
    Retrieve a parameter value or return the cached value

    Parameters
    ----------
    name: str
        Parameter name
    max_age: int
        Maximum age of the cached value
    transform: str
        Optional transformation of the parameter value. Supported values
        are &#34;json&#34; for JSON strings and &#34;binary&#34; for base 64 encoded
        values.
    force_fetch: bool, optional
        Force update even before a cached item has expired, defaults to False
    sdk_options: dict, optional
        Arguments that will be passed directly to the underlying API call

    Raises
    ------
    GetParameterError
        When the parameter provider fails to retrieve a parameter value for
        a given name.
    TransformParameterError
        When the parameter provider fails to transform a parameter value.
    &#34;&#34;&#34;

    # If there are multiple calls to the same parameter but in a different
    # transform, they will be stored multiple times. This allows us to
    # optimize by transforming the data only once per retrieval, thus there
    # is no need to transform cached values multiple times. However, this
    # means that we need to make multiple calls to the underlying parameter
    # store if we need to return it in different transforms. Since the number
    # of supported transform is small and the probability that a given
    # parameter will always be used in a specific transform, this should be
    # an acceptable tradeoff.
    key = (name, transform)

    if not force_fetch and self._has_not_expired(key):
        return self.store[key].value

    try:
        value = self._get(name, **sdk_options)
    # Encapsulate all errors into a generic GetParameterError
    except Exception as exc:
        raise GetParameterError(str(exc))

    if transform is not None:
        if isinstance(value, bytes):
            value = value.decode(&#34;utf-8&#34;)
        value = transform_value(value, transform)

    self.store[key] = ExpirableValue(value, datetime.now() + timedelta(seconds=max_age))

    return value</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.parameters.base.BaseProvider.get_multiple"><code class="name flex">
<span>def <span class="ident">get_multiple</span></span>(<span>self, path: str, max_age: int = 5, transform: Optional[str] = None, raise_on_transform_error: bool = False, force_fetch: bool = False, **sdk_options) ‑> Union[Dict[str, str], Dict[str, dict], Dict[str, bytes]]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve multiple parameters based on a path prefix</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Parameter path used to retrieve multiple parameters</dd>
<dt><strong><code>max_age</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum age of the cached value</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Optional transformation of the parameter value. Supported values
are "json" for JSON strings, "binary" for base 64 encoded
values or "auto" which looks at the attribute key to determine the type.</dd>
<dt><strong><code>raise_on_transform_error</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Raises an exception if any transform fails, otherwise this will
return a None value for each transform that failed</dd>
<dt><strong><code>force_fetch</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Force update even before a cached item has expired, defaults to False</dd>
<dt><strong><code>sdk_options</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Arguments that will be passed directly to the underlying API call</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GetParameterError</code></dt>
<dd>When the parameter provider fails to retrieve parameter values for
a given path.</dd>
<dt><code>TransformParameterError</code></dt>
<dd>When the parameter provider fails to transform a parameter value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_multiple(
    self,
    path: str,
    max_age: int = DEFAULT_MAX_AGE_SECS,
    transform: Optional[str] = None,
    raise_on_transform_error: bool = False,
    force_fetch: bool = False,
    **sdk_options,
) -&gt; Union[Dict[str, str], Dict[str, dict], Dict[str, bytes]]:
    &#34;&#34;&#34;
    Retrieve multiple parameters based on a path prefix

    Parameters
    ----------
    path: str
        Parameter path used to retrieve multiple parameters
    max_age: int, optional
        Maximum age of the cached value
    transform: str, optional
        Optional transformation of the parameter value. Supported values
        are &#34;json&#34; for JSON strings, &#34;binary&#34; for base 64 encoded
        values or &#34;auto&#34; which looks at the attribute key to determine the type.
    raise_on_transform_error: bool, optional
        Raises an exception if any transform fails, otherwise this will
        return a None value for each transform that failed
    force_fetch: bool, optional
        Force update even before a cached item has expired, defaults to False
    sdk_options: dict, optional
        Arguments that will be passed directly to the underlying API call

    Raises
    ------
    GetParameterError
        When the parameter provider fails to retrieve parameter values for
        a given path.
    TransformParameterError
        When the parameter provider fails to transform a parameter value.
    &#34;&#34;&#34;

    key = (path, transform)

    if not force_fetch and self._has_not_expired(key):
        return self.store[key].value

    try:
        values: Dict[str, Union[str, bytes, dict, None]] = self._get_multiple(path, **sdk_options)
    # Encapsulate all errors into a generic GetParameterError
    except Exception as exc:
        raise GetParameterError(str(exc))

    if transform is not None:
        for (key, value) in values.items():
            _transform = get_transform_method(key, transform)
            if _transform is None:
                continue

            values[key] = transform_value(value, _transform, raise_on_transform_error)

    self.store[key] = ExpirableValue(values, datetime.now() + timedelta(seconds=max_age))

    return values</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.parameters.base.ExpirableValue"><code class="flex name class">
<span>class <span class="ident">ExpirableValue</span></span>
<span>(</span><span>value, ttl)</span>
</code></dt>
<dd>
<div class="desc"><p>ExpirableValue(value, ttl)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parameters.base.ExpirableValue.ttl"><code class="name">var <span class="ident">ttl</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="aws_lambda_powertools.utilities.parameters.base.ExpirableValue.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aws_lambda_powertools.utilities.parameters" href="index.html">aws_lambda_powertools.utilities.parameters</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.get_transform_method" href="#aws_lambda_powertools.utilities.parameters.base.get_transform_method">get_transform_method</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.transform_value" href="#aws_lambda_powertools.utilities.parameters.base.transform_value">transform_value</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parameters.base.BaseProvider" href="#aws_lambda_powertools.utilities.parameters.base.BaseProvider">BaseProvider</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.BaseProvider.get" href="#aws_lambda_powertools.utilities.parameters.base.BaseProvider.get">get</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.BaseProvider.get_multiple" href="#aws_lambda_powertools.utilities.parameters.base.BaseProvider.get_multiple">get_multiple</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.BaseProvider.store" href="#aws_lambda_powertools.utilities.parameters.base.BaseProvider.store">store</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parameters.base.ExpirableValue" href="#aws_lambda_powertools.utilities.parameters.base.ExpirableValue">ExpirableValue</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.ExpirableValue.ttl" href="#aws_lambda_powertools.utilities.parameters.base.ExpirableValue.ttl">ttl</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.ExpirableValue.value" href="#aws_lambda_powertools.utilities.parameters.base.ExpirableValue.value">value</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>